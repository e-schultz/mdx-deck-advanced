import { FullScreenCode, Invert } from "mdx-deck/layouts";
import { Head, Appear, Image, withDeck } from 'mdx-deck'
import { CodeSurfer } from "mdx-deck-code-surfer";
import nightOwl from "prism-react-renderer/themes/nightOwl";
import ReplIt from "../../components/replit";
import CodeSandbox from "../../components/codesandbox";
import Box from "../../components/Box";
const BRANCH_NAME = 'master'; // tood: change before merge

export default Invert

# Props

---

# Props

- Props define the 'API' of the component and how it interacts within your application
- Props become the attributes on your component that you use to pass in data

---
<CodeSurfer
  code={require("!!raw-loader!./snippets/props.snippet")}
  theme={nightOwl}
  lang="jsx"
  title="Props 101"
  showNumbers
  steps={[
    {},
    {lines: [1], notes: "Each function is called with a single property: `props`"},
    {lines: [4], notes: "Attributes become keys on the prop object"},
     {
      tokens: {
        1: [5,15,16,17],
        4: [5,6]
      },
      notes: "name attribute becomes props.name"
    },{}
  ]}
/>
---

## Destructuring Props

- Props is an object that your component will always receive
- The object keys are the attributes you specify on the component
- You can destructure props in the component method

---
<CodeSurfer
  code={require("raw-loader!./snippets/destructuring.snippet")}
  theme={nightOwl}
  lang="jsx"
  title="These Components Are the Same"
  showNumbers
  steps={[
    {},
    {lines: [1], notes: "Each function is called with a single property: `props`"},
    {lines: [2], notes: "Need to access via prop.value"},
    {lines: [4], notes: "Or make use of Destructuring"},
    {lines: [5], notes: "And able to just use greeting and name"}
  ]}
/>

---

## Props

- A prop can be anything, including a function
- You can pass raw values or variables
- This makes your component dynamic

---

## Passing Prop Data

<Box width={'75vw'}>
  <CodeSandbox src="https://codesandbox.io/embed/3kv214881q?fontsize=14&hidenavigation=1"/>
</Box>

```notes
Changed example to not use a loop yet, as we haven't covered
rendering lists yet, or comnditional rendering
```
---

## Static Checking with PropTypes

- The React prop-types package allows you to check props being passed into a component
- Not like typescript; If an invalid prop type is passed, your app will still render
- You will instead receive warnings in the console

---
export default FullScreenCode

```javascript
import PropTypes from 'prop-types';

Card.propTypes = {
    id: PropTypes.number.isRequired,
    name: PropTypes.shape({
      firstName: string,
      lastName: string
    })
    email: PropTypes.string.isRequired
};
```

---

## Default Values

- The prop-types package also lets you specify defaults
- Specifying defaults can help you avoid null checking
- undefined values WILL overwrite default values

```javascript
ManyGreetings.defaultProps = {
  names: []
};
```

---

### Exercise 1 - Adding Props

* Create a component that takes two props - num1, num2
* The component should display the equation of "num1 + num2"
* The component should also display the result


---
export default FullScreenCode

### Props - Start

<CodeSandbox src="https://codesandbox.io/embed/9lnz3x7o1p?autoresize=1&fontsize=14&hidenavigation=1"/>

---
export default FullScreenCode

### Props - Solution

<CodeSandbox src="https://codesandbox.io/embed/4qz761yz49?fontsize=14"/>

---

# Break / Q&A
