import { Head, Appear, Image, withDeck } from 'mdx-deck'  // https://github.com/jxnblk/mdx-deck
import { CodeSurfer } from "mdx-deck-code-surfer"
import { FullScreenCode } from "mdx-deck/layouts";
import nightOwl from "prism-react-renderer/themes/nightOwl"
import ReplIt from "../../components/replit";
import  Code  from 'mdx-code';

# Promise Patterns  
---

## Promise Patterns - Parallel

- Finish in Any Order
- Promises Do Not Depend on the Success of Another 
- Only Care Once They All Finish 

---

## Promise Patterns - Waterfall

- Order Matters
- Another Request Needs the Result of a Previous 

---
## Promise Parallel - Promise.all

* Waits for All Promises to Resolve
* Gets Passed into the Handler as an Array

```javascript
let promiseA = someRequest("A");
let promiseB = someRequest("B");
let PromiseC = someRequest("C");

Promise.all([promiseA, promiseB, promiseC]).then(results => {
  console.log("Hello Results", results);
});
```

---
## Promise.all - can also use destructuring

- Waits for All Promises to Resolve
- Gets Passed into the Handler as an Array
- *note* : May need a polyfil for some browsers 

```javascript
let promiseA = someRequest("A");
let promiseB = someRequest("B");
let PromiseC = someRequest("C");

Promise.all([promiseA, promiseB, promiseC]).then(
  ([resultA, resultB, resultC]) => {
    console.log(resultA, resultB, resultC);
  }
);
```

---
## API Consideration 

<a href="https://js-ts-training.now.sh/" target="_blank">Simple API</a>
---

## Exercise Time: 

* Get a Game by ID
* Get a List of Platforms 
* Create a Game Object with the Game Name, and the Platform Name

```js
let expected = {
    id: 3,
    name: "Dragon Quest XI: Echoes of an Elusive Age",
    platformId: 1,
    platformName: "PS4"
  }

```
---
export default FullScreenCode

# Promise.all the things

<ReplIt src="https://repl.it/@e_schultz/Promise-Parallel-Start?lite=true"/>

---
export default FullScreenCode

# Promise.all the solution

<ReplIt src="https://repl.it/@e_schultz/Promise-Parallel-Solution?lite=true"/>

```notes
<div style={{height: '80vh', display: 'block'}}>
    <iframe height="100%" style={{height: '100%'}} width="100%" src="https://repl.it/@e_schultz/Promise-Parallel-Solution?lite=true" scrolling="no" frameBorder="no"  allowFullScreen={true} sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals">
    </iframe>
</div>
```
---
# Promise - waterfall 

* Same API as last time
* Maybe the Platform list is massive - and we want to get it by id
* Instead of returning all platforms
* Request a Game
* Request the Platform for that Game
* Display similar result.

---
export default FullScreenCode

## Promise - One Request then Another

<ReplIt src="https://repl.it/@e_schultz/Promise-Waterfall-Start?lite=true"/>

---
export default FullScreenCode

## Promise - One Request then Another Solution

<ReplIt src="https://repl.it/@e_schultz/Promise-Waterfall-Solution?lite=true"/>

---
## Flattening The Chain .... take 1

<ReplIt src="https://repl.it/@e_schultz/Promise-Waterfall-Solution-Flat-Solution?lite=true"/>

---
## Flattening The Chain .... take 2 

<ReplIt src="https://repl.it/@e_schultz/Promise-Waterfall-Solution-Flat-Solution-Alt?lite=true"/>

---

### Sequential Promises

* When a Promise Does Not Rely on the Result of Another
* Want to Run Sequentially Instead of in Parallel
* Why? Maybe API rate limiting will complain if you fire off 500 at once.
* Good for bulk operations where you may not care about the actual api response 

---

### Sequential Promises

* Promise.all executes in Parallel 
* No built in Sequential --- so lets build it.

---
export default FullScreenCode

### Sequential Promises - Example

<ReplIt src="https://repl.it/@e_schultz/Sequential-Promises-example?lite=true"/>

---
export default FullScreenCode

### Step Series Promises - Example

<ReplIt src="https://repl.it/@e_schultz/Step-Series-Promises-example-all-results?lite=true"/>

---

### Promisify Synchronous Values

* Sometimes you may want to turn a sync value into an async one
* Possibly you have mock data you will replace with a real API later
* Can also be used as a way to cache a value 

---
export default FullScreenCode

### Promisify Synchronous Values
<ReplIt src="https://repl.it/@e_schultz/Promisify-Sync-Data?lite=true"/>

```notes
const GAME_DATA = {
  1: { id: 1, name: 'God of War '},
  2: { id: 2, name: 'Octopath Traveler'},
  3: { id: 3, name: ' Dark Souls'},
}
function getGameData(id) {
  return GAME_DATA[id] ? Promise.resolve(GAME_DATA[id]) : Promise.reject('not found')
}

getGameData(1).then(n=>{
  console.log('found the game', n);
}).then(null,err=>{
  console.log('ooops', err)
});

getGameData(4).then(n=>{
  console.log('found the game', n);
}).then(null,err=>{
  console.log('ooops', err)
});
```
---

### Caching Async Data

* Promises can be reused
* If you store a promise, and return it again - you will get the previously resolved value

---
export default FullScreenCode

### Sync Cache Example

<ReplIt src="https://repl.it/@e_schultz/Sync-Cache-Example?lite=true"/>

---

### Promise Exercise - Cache the API Response 

* Check to see if a game has been requested yet
* If so - return the cached value
* If not - get the value and store it in the cache 

---
export default FullScreenCode

### Promise Cache - Start

<ReplIt src="https://repl.it/@e_schultz/Promise-Cache-Exercise-start?lite=true"/>


---
export default FullScreenCode

### Promise Cache - Solution

<ReplIt src="https://repl.it/@e_schultz/Promise-Cache-Exercise-start?lite=true"/>

---

### Promise Exercise - Bonus

* Make a generic cache for any fetch request - regardless of Games, Platform, etc. 
* How would you approach this?

---
### Promise Exercise - Bonus - Start 

export default FullScreenCode

<ReplIt src="https://repl.it/@e_schultz/Promise-Cache-Exercise-Bonus-Start?lite=true"/>

---
### Promise Exercise - Bonus - Solution

## None yet - no peeking! 

---

# Break / Q&A 

